"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/iron-session";
exports.ids = ["vendor-chunks/iron-session"];
exports.modules = {

/***/ "(rsc)/./node_modules/iron-session/node_modules/cookie/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/iron-session/node_modules/cookie/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module exports.\n * @public\n */\n\nexports.parse = parse;\nexports.serialize = serialize;\n\n/**\n * Module variables.\n * @private\n */\n\nvar __toString = Object.prototype.toString\nvar __hasOwnProperty = Object.prototype.hasOwnProperty\n\n/**\n * RegExp to match cookie-name in RFC 6265 sec 4.1.1\n * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2\n * which has been replaced by the token definition in RFC 7230 appendix B.\n *\n * cookie-name       = token\n * token             = 1*tchar\n * tchar             = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" /\n *                     \"*\" / \"+\" / \"-\" / \".\" / \"^\" / \"_\" /\n *                     \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\n */\n\nvar cookieNameRegExp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\n\n/**\n * RegExp to match cookie-value in RFC 6265 sec 4.1.1\n *\n * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n *                     ; US-ASCII characters excluding CTLs,\n *                     ; whitespace DQUOTE, comma, semicolon,\n *                     ; and backslash\n */\n\nvar cookieValueRegExp = /^(\"?)[\\u0021\\u0023-\\u002B\\u002D-\\u003A\\u003C-\\u005B\\u005D-\\u007E]*\\1$/;\n\n/**\n * RegExp to match domain-value in RFC 6265 sec 4.1.1\n *\n * domain-value      = <subdomain>\n *                     ; defined in [RFC1034], Section 3.5, as\n *                     ; enhanced by [RFC1123], Section 2.1\n * <subdomain>       = <label> | <subdomain> \".\" <label>\n * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]\n *                     Labels must be 63 characters or less.\n *                     'let-dig' not 'letter' in the first char, per RFC1123\n * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>\n * <let-dig-hyp>     = <let-dig> | \"-\"\n * <let-dig>         = <letter> | <digit>\n * <letter>          = any one of the 52 alphabetic characters A through Z in\n *                     upper case and a through z in lower case\n * <digit>           = any one of the ten digits 0 through 9\n *\n * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173\n *\n * > (Note that a leading %x2E (\".\"), if present, is ignored even though that\n * character is not permitted, but a trailing %x2E (\".\"), if present, will\n * cause the user agent to ignore the attribute.)\n */\n\nvar domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;\n\n/**\n * RegExp to match path-value in RFC 6265 sec 4.1.1\n *\n * path-value        = <any CHAR except CTLs or \";\">\n * CHAR              = %x01-7F\n *                     ; defined in RFC 5234 appendix B.1\n */\n\nvar pathValueRegExp = /^[\\u0020-\\u003A\\u003D-\\u007E]*$/;\n\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n *\n * @param {string} str\n * @param {object} [opt]\n * @return {object}\n * @public\n */\n\nfunction parse(str, opt) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string');\n  }\n\n  var obj = {};\n  var len = str.length;\n  // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.\n  if (len < 2) return obj;\n\n  var dec = (opt && opt.decode) || decode;\n  var index = 0;\n  var eqIdx = 0;\n  var endIdx = 0;\n\n  do {\n    eqIdx = str.indexOf('=', index);\n    if (eqIdx === -1) break; // No more cookie pairs.\n\n    endIdx = str.indexOf(';', index);\n\n    if (endIdx === -1) {\n      endIdx = len;\n    } else if (eqIdx > endIdx) {\n      // backtrack on prior semicolon\n      index = str.lastIndexOf(';', eqIdx - 1) + 1;\n      continue;\n    }\n\n    var keyStartIdx = startIndex(str, index, eqIdx);\n    var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);\n    var key = str.slice(keyStartIdx, keyEndIdx);\n\n    // only assign once\n    if (!__hasOwnProperty.call(obj, key)) {\n      var valStartIdx = startIndex(str, eqIdx + 1, endIdx);\n      var valEndIdx = endIndex(str, endIdx, valStartIdx);\n\n      if (str.charCodeAt(valStartIdx) === 0x22 /* \" */ && str.charCodeAt(valEndIdx - 1) === 0x22 /* \" */) {\n        valStartIdx++;\n        valEndIdx--;\n      }\n\n      var val = str.slice(valStartIdx, valEndIdx);\n      obj[key] = tryDecode(val, dec);\n    }\n\n    index = endIdx + 1\n  } while (index < len);\n\n  return obj;\n}\n\nfunction startIndex(str, index, max) {\n  do {\n    var code = str.charCodeAt(index);\n    if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */) return index;\n  } while (++index < max);\n  return max;\n}\n\nfunction endIndex(str, index, min) {\n  while (index > min) {\n    var code = str.charCodeAt(--index);\n    if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */) return index + 1;\n  }\n  return min;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize a name value pair into a cookie string suitable for\n * http headers. An optional options object specifies cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n *\n * @param {string} name\n * @param {string} val\n * @param {object} [opt]\n * @return {string}\n * @public\n */\n\nfunction serialize(name, val, opt) {\n  var enc = (opt && opt.encode) || encodeURIComponent;\n\n  if (typeof enc !== 'function') {\n    throw new TypeError('option encode is invalid');\n  }\n\n  if (!cookieNameRegExp.test(name)) {\n    throw new TypeError('argument name is invalid');\n  }\n\n  var value = enc(val);\n\n  if (!cookieValueRegExp.test(value)) {\n    throw new TypeError('argument val is invalid');\n  }\n\n  var str = name + '=' + value;\n  if (!opt) return str;\n\n  if (null != opt.maxAge) {\n    var maxAge = Math.floor(opt.maxAge);\n\n    if (!isFinite(maxAge)) {\n      throw new TypeError('option maxAge is invalid')\n    }\n\n    str += '; Max-Age=' + maxAge;\n  }\n\n  if (opt.domain) {\n    if (!domainValueRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n\n    str += '; Domain=' + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!pathValueRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n\n    str += '; Path=' + opt.path;\n  }\n\n  if (opt.expires) {\n    var expires = opt.expires\n\n    if (!isDate(expires) || isNaN(expires.valueOf())) {\n      throw new TypeError('option expires is invalid');\n    }\n\n    str += '; Expires=' + expires.toUTCString()\n  }\n\n  if (opt.httpOnly) {\n    str += '; HttpOnly';\n  }\n\n  if (opt.secure) {\n    str += '; Secure';\n  }\n\n  if (opt.partitioned) {\n    str += '; Partitioned'\n  }\n\n  if (opt.priority) {\n    var priority = typeof opt.priority === 'string'\n      ? opt.priority.toLowerCase() : opt.priority;\n\n    switch (priority) {\n      case 'low':\n        str += '; Priority=Low'\n        break\n      case 'medium':\n        str += '; Priority=Medium'\n        break\n      case 'high':\n        str += '; Priority=High'\n        break\n      default:\n        throw new TypeError('option priority is invalid')\n    }\n  }\n\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string'\n      ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      case 'none':\n        str += '; SameSite=None';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n\n  return str;\n}\n\n/**\n * URL-decode string value. Optimized to skip native call when no %.\n *\n * @param {string} str\n * @returns {string}\n */\n\nfunction decode (str) {\n  return str.indexOf('%') !== -1\n    ? decodeURIComponent(str)\n    : str\n}\n\n/**\n * Determine if value is a Date.\n *\n * @param {*} val\n * @private\n */\n\nfunction isDate (val) {\n  return __toString.call(val) === '[object Date]';\n}\n\n/**\n * Try decoding a string using a decoding function.\n *\n * @param {string} str\n * @param {function} decode\n * @private\n */\n\nfunction tryDecode(str, decode) {\n  try {\n    return decode(str);\n  } catch (e) {\n    return str;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXJvbi1zZXNzaW9uL25vZGVfbW9kdWxlcy9jb29raWUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYixpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtELEtBQUssa0NBQWtDLEtBQUs7O0FBRTlGO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0JBQWdCO0FBQzdDLGtCQUFrQjtBQUNsQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXE5leHRKU1xcbWVkaWNhbCB3ZWJzaXRlXFxtZWRpY2FsLWNsaW5pY1xcbm9kZV9tb2R1bGVzXFxpcm9uLXNlc3Npb25cXG5vZGVfbW9kdWxlc1xcY29va2llXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGNvb2tpZVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBSb21hbiBTaHR5bG1hblxuICogQ29weXJpZ2h0KGMpIDIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcblxuLyoqXG4gKiBNb2R1bGUgdmFyaWFibGVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgX190b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbnZhciBfX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuXG4vKipcbiAqIFJlZ0V4cCB0byBtYXRjaCBjb29raWUtbmFtZSBpbiBSRkMgNjI2NSBzZWMgNC4xLjFcbiAqIFRoaXMgcmVmZXJzIG91dCB0byB0aGUgb2Jzb2xldGVkIGRlZmluaXRpb24gb2YgdG9rZW4gaW4gUkZDIDI2MTYgc2VjIDIuMlxuICogd2hpY2ggaGFzIGJlZW4gcmVwbGFjZWQgYnkgdGhlIHRva2VuIGRlZmluaXRpb24gaW4gUkZDIDcyMzAgYXBwZW5kaXggQi5cbiAqXG4gKiBjb29raWUtbmFtZSAgICAgICA9IHRva2VuXG4gKiB0b2tlbiAgICAgICAgICAgICA9IDEqdGNoYXJcbiAqIHRjaGFyICAgICAgICAgICAgID0gXCIhXCIgLyBcIiNcIiAvIFwiJFwiIC8gXCIlXCIgLyBcIiZcIiAvIFwiJ1wiIC9cbiAqICAgICAgICAgICAgICAgICAgICAgXCIqXCIgLyBcIitcIiAvIFwiLVwiIC8gXCIuXCIgLyBcIl5cIiAvIFwiX1wiIC9cbiAqICAgICAgICAgICAgICAgICAgICAgXCJgXCIgLyBcInxcIiAvIFwiflwiIC8gRElHSVQgLyBBTFBIQVxuICovXG5cbnZhciBjb29raWVOYW1lUmVnRXhwID0gL15bISMkJSYnKitcXC0uXl9gfH4wLTlBLVphLXpdKyQvO1xuXG4vKipcbiAqIFJlZ0V4cCB0byBtYXRjaCBjb29raWUtdmFsdWUgaW4gUkZDIDYyNjUgc2VjIDQuMS4xXG4gKlxuICogY29va2llLXZhbHVlICAgICAgPSAqY29va2llLW9jdGV0IC8gKCBEUVVPVEUgKmNvb2tpZS1vY3RldCBEUVVPVEUgKVxuICogY29va2llLW9jdGV0ICAgICAgPSAleDIxIC8gJXgyMy0yQiAvICV4MkQtM0EgLyAleDNDLTVCIC8gJXg1RC03RVxuICogICAgICAgICAgICAgICAgICAgICA7IFVTLUFTQ0lJIGNoYXJhY3RlcnMgZXhjbHVkaW5nIENUTHMsXG4gKiAgICAgICAgICAgICAgICAgICAgIDsgd2hpdGVzcGFjZSBEUVVPVEUsIGNvbW1hLCBzZW1pY29sb24sXG4gKiAgICAgICAgICAgICAgICAgICAgIDsgYW5kIGJhY2tzbGFzaFxuICovXG5cbnZhciBjb29raWVWYWx1ZVJlZ0V4cCA9IC9eKFwiPylbXFx1MDAyMVxcdTAwMjMtXFx1MDAyQlxcdTAwMkQtXFx1MDAzQVxcdTAwM0MtXFx1MDA1QlxcdTAwNUQtXFx1MDA3RV0qXFwxJC87XG5cbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoIGRvbWFpbi12YWx1ZSBpbiBSRkMgNjI2NSBzZWMgNC4xLjFcbiAqXG4gKiBkb21haW4tdmFsdWUgICAgICA9IDxzdWJkb21haW4+XG4gKiAgICAgICAgICAgICAgICAgICAgIDsgZGVmaW5lZCBpbiBbUkZDMTAzNF0sIFNlY3Rpb24gMy41LCBhc1xuICogICAgICAgICAgICAgICAgICAgICA7IGVuaGFuY2VkIGJ5IFtSRkMxMTIzXSwgU2VjdGlvbiAyLjFcbiAqIDxzdWJkb21haW4+ICAgICAgID0gPGxhYmVsPiB8IDxzdWJkb21haW4+IFwiLlwiIDxsYWJlbD5cbiAqIDxsYWJlbD4gICAgICAgICAgID0gPGxldC1kaWc+IFsgWyA8bGRoLXN0cj4gXSA8bGV0LWRpZz4gXVxuICogICAgICAgICAgICAgICAgICAgICBMYWJlbHMgbXVzdCBiZSA2MyBjaGFyYWN0ZXJzIG9yIGxlc3MuXG4gKiAgICAgICAgICAgICAgICAgICAgICdsZXQtZGlnJyBub3QgJ2xldHRlcicgaW4gdGhlIGZpcnN0IGNoYXIsIHBlciBSRkMxMTIzXG4gKiA8bGRoLXN0cj4gICAgICAgICA9IDxsZXQtZGlnLWh5cD4gfCA8bGV0LWRpZy1oeXA+IDxsZGgtc3RyPlxuICogPGxldC1kaWctaHlwPiAgICAgPSA8bGV0LWRpZz4gfCBcIi1cIlxuICogPGxldC1kaWc+ICAgICAgICAgPSA8bGV0dGVyPiB8IDxkaWdpdD5cbiAqIDxsZXR0ZXI+ICAgICAgICAgID0gYW55IG9uZSBvZiB0aGUgNTIgYWxwaGFiZXRpYyBjaGFyYWN0ZXJzIEEgdGhyb3VnaCBaIGluXG4gKiAgICAgICAgICAgICAgICAgICAgIHVwcGVyIGNhc2UgYW5kIGEgdGhyb3VnaCB6IGluIGxvd2VyIGNhc2VcbiAqIDxkaWdpdD4gICAgICAgICAgID0gYW55IG9uZSBvZiB0aGUgdGVuIGRpZ2l0cyAwIHRocm91Z2ggOVxuICpcbiAqIEtlZXAgc3VwcG9ydCBmb3IgbGVhZGluZyBkb3Q6IGh0dHBzOi8vZ2l0aHViLmNvbS9qc2h0dHAvY29va2llL2lzc3Vlcy8xNzNcbiAqXG4gKiA+IChOb3RlIHRoYXQgYSBsZWFkaW5nICV4MkUgKFwiLlwiKSwgaWYgcHJlc2VudCwgaXMgaWdub3JlZCBldmVuIHRob3VnaCB0aGF0XG4gKiBjaGFyYWN0ZXIgaXMgbm90IHBlcm1pdHRlZCwgYnV0IGEgdHJhaWxpbmcgJXgyRSAoXCIuXCIpLCBpZiBwcmVzZW50LCB3aWxsXG4gKiBjYXVzZSB0aGUgdXNlciBhZ2VudCB0byBpZ25vcmUgdGhlIGF0dHJpYnV0ZS4pXG4gKi9cblxudmFyIGRvbWFpblZhbHVlUmVnRXhwID0gL14oWy5dP1thLXowLTldKFthLXowLTktXXswLDYxfVthLXowLTldKT8pKFsuXVthLXowLTldKFthLXowLTktXXswLDYxfVthLXowLTldKT8pKiQvaTtcblxuLyoqXG4gKiBSZWdFeHAgdG8gbWF0Y2ggcGF0aC12YWx1ZSBpbiBSRkMgNjI2NSBzZWMgNC4xLjFcbiAqXG4gKiBwYXRoLXZhbHVlICAgICAgICA9IDxhbnkgQ0hBUiBleGNlcHQgQ1RMcyBvciBcIjtcIj5cbiAqIENIQVIgICAgICAgICAgICAgID0gJXgwMS03RlxuICogICAgICAgICAgICAgICAgICAgICA7IGRlZmluZWQgaW4gUkZDIDUyMzQgYXBwZW5kaXggQi4xXG4gKi9cblxudmFyIHBhdGhWYWx1ZVJlZ0V4cCA9IC9eW1xcdTAwMjAtXFx1MDAzQVxcdTAwM0QtXFx1MDA3RV0qJC87XG5cbi8qKlxuICogUGFyc2UgYSBjb29raWUgaGVhZGVyLlxuICpcbiAqIFBhcnNlIHRoZSBnaXZlbiBjb29raWUgaGVhZGVyIHN0cmluZyBpbnRvIGFuIG9iamVjdFxuICogVGhlIG9iamVjdCBoYXMgdGhlIHZhcmlvdXMgY29va2llcyBhcyBrZXlzKG5hbWVzKSA9PiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdF1cbiAqIEByZXR1cm4ge29iamVjdH1cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIsIG9wdCkge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzdHIgbXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgdmFyIG9iaiA9IHt9O1xuICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcbiAgLy8gUkZDIDYyNjUgc2VjIDQuMS4xLCBSRkMgMjYxNiAyLjIgZGVmaW5lcyBhIGNvb2tpZSBuYW1lIGNvbnNpc3RzIG9mIG9uZSBjaGFyIG1pbmltdW0sIHBsdXMgJz0nLlxuICBpZiAobGVuIDwgMikgcmV0dXJuIG9iajtcblxuICB2YXIgZGVjID0gKG9wdCAmJiBvcHQuZGVjb2RlKSB8fCBkZWNvZGU7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBlcUlkeCA9IDA7XG4gIHZhciBlbmRJZHggPSAwO1xuXG4gIGRvIHtcbiAgICBlcUlkeCA9IHN0ci5pbmRleE9mKCc9JywgaW5kZXgpO1xuICAgIGlmIChlcUlkeCA9PT0gLTEpIGJyZWFrOyAvLyBObyBtb3JlIGNvb2tpZSBwYWlycy5cblxuICAgIGVuZElkeCA9IHN0ci5pbmRleE9mKCc7JywgaW5kZXgpO1xuXG4gICAgaWYgKGVuZElkeCA9PT0gLTEpIHtcbiAgICAgIGVuZElkeCA9IGxlbjtcbiAgICB9IGVsc2UgaWYgKGVxSWR4ID4gZW5kSWR4KSB7XG4gICAgICAvLyBiYWNrdHJhY2sgb24gcHJpb3Igc2VtaWNvbG9uXG4gICAgICBpbmRleCA9IHN0ci5sYXN0SW5kZXhPZignOycsIGVxSWR4IC0gMSkgKyAxO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGtleVN0YXJ0SWR4ID0gc3RhcnRJbmRleChzdHIsIGluZGV4LCBlcUlkeCk7XG4gICAgdmFyIGtleUVuZElkeCA9IGVuZEluZGV4KHN0ciwgZXFJZHgsIGtleVN0YXJ0SWR4KTtcbiAgICB2YXIga2V5ID0gc3RyLnNsaWNlKGtleVN0YXJ0SWR4LCBrZXlFbmRJZHgpO1xuXG4gICAgLy8gb25seSBhc3NpZ24gb25jZVxuICAgIGlmICghX19oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgdmFyIHZhbFN0YXJ0SWR4ID0gc3RhcnRJbmRleChzdHIsIGVxSWR4ICsgMSwgZW5kSWR4KTtcbiAgICAgIHZhciB2YWxFbmRJZHggPSBlbmRJbmRleChzdHIsIGVuZElkeCwgdmFsU3RhcnRJZHgpO1xuXG4gICAgICBpZiAoc3RyLmNoYXJDb2RlQXQodmFsU3RhcnRJZHgpID09PSAweDIyIC8qIFwiICovICYmIHN0ci5jaGFyQ29kZUF0KHZhbEVuZElkeCAtIDEpID09PSAweDIyIC8qIFwiICovKSB7XG4gICAgICAgIHZhbFN0YXJ0SWR4Kys7XG4gICAgICAgIHZhbEVuZElkeC0tO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsID0gc3RyLnNsaWNlKHZhbFN0YXJ0SWR4LCB2YWxFbmRJZHgpO1xuICAgICAgb2JqW2tleV0gPSB0cnlEZWNvZGUodmFsLCBkZWMpO1xuICAgIH1cblxuICAgIGluZGV4ID0gZW5kSWR4ICsgMVxuICB9IHdoaWxlIChpbmRleCA8IGxlbik7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gc3RhcnRJbmRleChzdHIsIGluZGV4LCBtYXgpIHtcbiAgZG8ge1xuICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgIGlmIChjb2RlICE9PSAweDIwIC8qICAgKi8gJiYgY29kZSAhPT0gMHgwOSAvKiBcXHQgKi8pIHJldHVybiBpbmRleDtcbiAgfSB3aGlsZSAoKytpbmRleCA8IG1heCk7XG4gIHJldHVybiBtYXg7XG59XG5cbmZ1bmN0aW9uIGVuZEluZGV4KHN0ciwgaW5kZXgsIG1pbikge1xuICB3aGlsZSAoaW5kZXggPiBtaW4pIHtcbiAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KC0taW5kZXgpO1xuICAgIGlmIChjb2RlICE9PSAweDIwIC8qICAgKi8gJiYgY29kZSAhPT0gMHgwOSAvKiBcXHQgKi8pIHJldHVybiBpbmRleCArIDE7XG4gIH1cbiAgcmV0dXJuIG1pbjtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgZGF0YSBpbnRvIGEgY29va2llIGhlYWRlci5cbiAqXG4gKiBTZXJpYWxpemUgYSBuYW1lIHZhbHVlIHBhaXIgaW50byBhIGNvb2tpZSBzdHJpbmcgc3VpdGFibGUgZm9yXG4gKiBodHRwIGhlYWRlcnMuIEFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHNwZWNpZmllcyBjb29raWUgcGFyYW1ldGVycy5cbiAqXG4gKiBzZXJpYWxpemUoJ2ZvbycsICdiYXInLCB7IGh0dHBPbmx5OiB0cnVlIH0pXG4gKiAgID0+IFwiZm9vPWJhcjsgaHR0cE9ubHlcIlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdF1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBzZXJpYWxpemUobmFtZSwgdmFsLCBvcHQpIHtcbiAgdmFyIGVuYyA9IChvcHQgJiYgb3B0LmVuY29kZSkgfHwgZW5jb2RlVVJJQ29tcG9uZW50O1xuXG4gIGlmICh0eXBlb2YgZW5jICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIGVuY29kZSBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICBpZiAoIWNvb2tpZU5hbWVSZWdFeHAudGVzdChuYW1lKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IG5hbWUgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gZW5jKHZhbCk7XG5cbiAgaWYgKCFjb29raWVWYWx1ZVJlZ0V4cC50ZXN0KHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHZhbCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICB2YXIgc3RyID0gbmFtZSArICc9JyArIHZhbHVlO1xuICBpZiAoIW9wdCkgcmV0dXJuIHN0cjtcblxuICBpZiAobnVsbCAhPSBvcHQubWF4QWdlKSB7XG4gICAgdmFyIG1heEFnZSA9IE1hdGguZmxvb3Iob3B0Lm1heEFnZSk7XG5cbiAgICBpZiAoIWlzRmluaXRlKG1heEFnZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBtYXhBZ2UgaXMgaW52YWxpZCcpXG4gICAgfVxuXG4gICAgc3RyICs9ICc7IE1heC1BZ2U9JyArIG1heEFnZTtcbiAgfVxuXG4gIGlmIChvcHQuZG9tYWluKSB7XG4gICAgaWYgKCFkb21haW5WYWx1ZVJlZ0V4cC50ZXN0KG9wdC5kb21haW4pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gZG9tYWluIGlzIGludmFsaWQnKTtcbiAgICB9XG5cbiAgICBzdHIgKz0gJzsgRG9tYWluPScgKyBvcHQuZG9tYWluO1xuICB9XG5cbiAgaWYgKG9wdC5wYXRoKSB7XG4gICAgaWYgKCFwYXRoVmFsdWVSZWdFeHAudGVzdChvcHQucGF0aCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBwYXRoIGlzIGludmFsaWQnKTtcbiAgICB9XG5cbiAgICBzdHIgKz0gJzsgUGF0aD0nICsgb3B0LnBhdGg7XG4gIH1cblxuICBpZiAob3B0LmV4cGlyZXMpIHtcbiAgICB2YXIgZXhwaXJlcyA9IG9wdC5leHBpcmVzXG5cbiAgICBpZiAoIWlzRGF0ZShleHBpcmVzKSB8fCBpc05hTihleHBpcmVzLnZhbHVlT2YoKSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBleHBpcmVzIGlzIGludmFsaWQnKTtcbiAgICB9XG5cbiAgICBzdHIgKz0gJzsgRXhwaXJlcz0nICsgZXhwaXJlcy50b1VUQ1N0cmluZygpXG4gIH1cblxuICBpZiAob3B0Lmh0dHBPbmx5KSB7XG4gICAgc3RyICs9ICc7IEh0dHBPbmx5JztcbiAgfVxuXG4gIGlmIChvcHQuc2VjdXJlKSB7XG4gICAgc3RyICs9ICc7IFNlY3VyZSc7XG4gIH1cblxuICBpZiAob3B0LnBhcnRpdGlvbmVkKSB7XG4gICAgc3RyICs9ICc7IFBhcnRpdGlvbmVkJ1xuICB9XG5cbiAgaWYgKG9wdC5wcmlvcml0eSkge1xuICAgIHZhciBwcmlvcml0eSA9IHR5cGVvZiBvcHQucHJpb3JpdHkgPT09ICdzdHJpbmcnXG4gICAgICA/IG9wdC5wcmlvcml0eS50b0xvd2VyQ2FzZSgpIDogb3B0LnByaW9yaXR5O1xuXG4gICAgc3dpdGNoIChwcmlvcml0eSkge1xuICAgICAgY2FzZSAnbG93JzpcbiAgICAgICAgc3RyICs9ICc7IFByaW9yaXR5PUxvdydcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21lZGl1bSc6XG4gICAgICAgIHN0ciArPSAnOyBQcmlvcml0eT1NZWRpdW0nXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdoaWdoJzpcbiAgICAgICAgc3RyICs9ICc7IFByaW9yaXR5PUhpZ2gnXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gcHJpb3JpdHkgaXMgaW52YWxpZCcpXG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdC5zYW1lU2l0ZSkge1xuICAgIHZhciBzYW1lU2l0ZSA9IHR5cGVvZiBvcHQuc2FtZVNpdGUgPT09ICdzdHJpbmcnXG4gICAgICA/IG9wdC5zYW1lU2l0ZS50b0xvd2VyQ2FzZSgpIDogb3B0LnNhbWVTaXRlO1xuXG4gICAgc3dpdGNoIChzYW1lU2l0ZSkge1xuICAgICAgY2FzZSB0cnVlOlxuICAgICAgICBzdHIgKz0gJzsgU2FtZVNpdGU9U3RyaWN0JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsYXgnOlxuICAgICAgICBzdHIgKz0gJzsgU2FtZVNpdGU9TGF4JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdHJpY3QnOlxuICAgICAgICBzdHIgKz0gJzsgU2FtZVNpdGU9U3RyaWN0JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdub25lJzpcbiAgICAgICAgc3RyICs9ICc7IFNhbWVTaXRlPU5vbmUnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBzYW1lU2l0ZSBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBVUkwtZGVjb2RlIHN0cmluZyB2YWx1ZS4gT3B0aW1pemVkIHRvIHNraXAgbmF0aXZlIGNhbGwgd2hlbiBubyAlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZGVjb2RlIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5pbmRleE9mKCclJykgIT09IC0xXG4gICAgPyBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICAgIDogc3RyXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHZhbHVlIGlzIGEgRGF0ZS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0RhdGUgKHZhbCkge1xuICByZXR1cm4gX190b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBUcnkgZGVjb2RpbmcgYSBzdHJpbmcgdXNpbmcgYSBkZWNvZGluZyBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkZWNvZGVcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gdHJ5RGVjb2RlKHN0ciwgZGVjb2RlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZShzdHIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/iron-session/node_modules/cookie/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/iron-session/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/iron-session/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getIronSession: () => (/* binding */ getIronSession),\n/* harmony export */   sealData: () => (/* binding */ sealData),\n/* harmony export */   unsealData: () => (/* binding */ unsealData)\n/* harmony export */ });\n/* harmony import */ var cookie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cookie */ \"(rsc)/./node_modules/iron-session/node_modules/cookie/index.js\");\n/* harmony import */ var iron_webcrypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! iron-webcrypto */ \"(rsc)/./node_modules/iron-webcrypto/dist/index.js\");\n/* harmony import */ var uncrypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uncrypto */ \"(rsc)/./node_modules/uncrypto/dist/crypto.node.mjs\");\n\n\n\n\n// src/core.ts\nvar timestampSkewSec = 60;\nvar fourteenDaysInSeconds = 14 * 24 * 3600;\nvar currentMajorVersion = 2;\nvar versionDelimiter = \"~\";\nvar defaultOptions = {\n  ttl: fourteenDaysInSeconds,\n  cookieOptions: { httpOnly: true, secure: true, sameSite: \"lax\", path: \"/\" }\n};\nfunction normalizeStringPasswordToMap(password) {\n  return typeof password === \"string\" ? { 1: password } : password;\n}\nfunction parseSeal(seal) {\n  const [sealWithoutVersion, tokenVersionAsString] = seal.split(versionDelimiter);\n  const tokenVersion = tokenVersionAsString == null ? null : parseInt(tokenVersionAsString, 10);\n  return { sealWithoutVersion, tokenVersion };\n}\nfunction computeCookieMaxAge(ttl) {\n  if (ttl === 0) {\n    return 2147483647;\n  }\n  return ttl - timestampSkewSec;\n}\nfunction getCookie(req, cookieName) {\n  return (0,cookie__WEBPACK_IMPORTED_MODULE_0__.parse)(\n    (\"headers\" in req && typeof req.headers.get === \"function\" ? req.headers.get(\"cookie\") : req.headers.cookie) ?? \"\"\n  )[cookieName] ?? \"\";\n}\nfunction getServerActionCookie(cookieName, cookieHandler) {\n  const cookieObject = cookieHandler.get(cookieName);\n  const cookie = cookieObject?.value;\n  if (typeof cookie === \"string\") {\n    return cookie;\n  }\n  return \"\";\n}\nfunction setCookie(res, cookieValue) {\n  if (\"headers\" in res && typeof res.headers.append === \"function\") {\n    res.headers.append(\"set-cookie\", cookieValue);\n    return;\n  }\n  let existingSetCookie = res.getHeader(\"set-cookie\") ?? [];\n  if (!Array.isArray(existingSetCookie)) {\n    existingSetCookie = [existingSetCookie.toString()];\n  }\n  res.setHeader(\"set-cookie\", [\n    ...existingSetCookie,\n    cookieValue\n  ]);\n}\nfunction createSealData(_crypto) {\n  return async function sealData2(data, {\n    password,\n    ttl = fourteenDaysInSeconds\n  }) {\n    const passwordsMap = normalizeStringPasswordToMap(password);\n    const mostRecentPasswordId = Math.max(\n      ...Object.keys(passwordsMap).map(Number)\n    );\n    const passwordForSeal = {\n      id: mostRecentPasswordId.toString(),\n      secret: passwordsMap[mostRecentPasswordId]\n    };\n    const seal$1 = await (0,iron_webcrypto__WEBPACK_IMPORTED_MODULE_1__.seal)(_crypto, data, passwordForSeal, {\n      ...iron_webcrypto__WEBPACK_IMPORTED_MODULE_1__.defaults,\n      ttl: ttl * 1e3\n    });\n    return `${seal$1}${versionDelimiter}${currentMajorVersion}`;\n  };\n}\nfunction createUnsealData(_crypto) {\n  return async function unsealData2(seal, {\n    password,\n    ttl = fourteenDaysInSeconds\n  }) {\n    const passwordsMap = normalizeStringPasswordToMap(password);\n    const { sealWithoutVersion, tokenVersion } = parseSeal(seal);\n    try {\n      const data = await (0,iron_webcrypto__WEBPACK_IMPORTED_MODULE_1__.unseal)(_crypto, sealWithoutVersion, passwordsMap, {\n        ...iron_webcrypto__WEBPACK_IMPORTED_MODULE_1__.defaults,\n        ttl: ttl * 1e3\n      }) ?? {};\n      if (tokenVersion === 2) {\n        return data;\n      }\n      return { ...data.persistent };\n    } catch (error) {\n      if (error instanceof Error && /^(Expired seal|Bad hmac value|Cannot find password|Incorrect number of sealed components)/.test(\n        error.message\n      )) {\n        return {};\n      }\n      throw error;\n    }\n  };\n}\nfunction getSessionConfig(sessionOptions) {\n  const options = {\n    ...defaultOptions,\n    ...sessionOptions,\n    cookieOptions: {\n      ...defaultOptions.cookieOptions,\n      ...sessionOptions.cookieOptions || {}\n    }\n  };\n  if (sessionOptions.cookieOptions && \"maxAge\" in sessionOptions.cookieOptions) {\n    if (sessionOptions.cookieOptions.maxAge === void 0) {\n      options.ttl = 0;\n    }\n  } else {\n    options.cookieOptions.maxAge = computeCookieMaxAge(options.ttl);\n  }\n  return options;\n}\nvar badUsageMessage = \"iron-session: Bad usage: use getIronSession(req, res, options) or getIronSession(cookieStore, options).\";\nfunction createGetIronSession(sealData2, unsealData2) {\n  return getIronSession2;\n  async function getIronSession2(reqOrCookieStore, resOrsessionOptions, sessionOptions) {\n    if (!reqOrCookieStore) {\n      throw new Error(badUsageMessage);\n    }\n    if (!resOrsessionOptions) {\n      throw new Error(badUsageMessage);\n    }\n    if (!sessionOptions) {\n      return getIronSessionFromCookieStore(\n        reqOrCookieStore,\n        resOrsessionOptions,\n        sealData2,\n        unsealData2\n      );\n    }\n    const req = reqOrCookieStore;\n    const res = resOrsessionOptions;\n    if (!sessionOptions) {\n      throw new Error(badUsageMessage);\n    }\n    if (!sessionOptions.cookieName) {\n      throw new Error(\"iron-session: Bad usage. Missing cookie name.\");\n    }\n    if (!sessionOptions.password) {\n      throw new Error(\"iron-session: Bad usage. Missing password.\");\n    }\n    const passwordsMap = normalizeStringPasswordToMap(sessionOptions.password);\n    if (Object.values(passwordsMap).some((password) => password.length < 32)) {\n      throw new Error(\n        \"iron-session: Bad usage. Password must be at least 32 characters long.\"\n      );\n    }\n    let sessionConfig = getSessionConfig(sessionOptions);\n    const sealFromCookies = getCookie(req, sessionConfig.cookieName);\n    const session = sealFromCookies ? await unsealData2(sealFromCookies, {\n      password: passwordsMap,\n      ttl: sessionConfig.ttl\n    }) : {};\n    Object.defineProperties(session, {\n      updateConfig: {\n        value: function updateConfig(newSessionOptions) {\n          sessionConfig = getSessionConfig(newSessionOptions);\n        }\n      },\n      save: {\n        value: async function save() {\n          if (\"headersSent\" in res && res.headersSent) {\n            throw new Error(\n              \"iron-session: Cannot set session cookie: session.save() was called after headers were sent. Make sure to call it before any res.send() or res.end()\"\n            );\n          }\n          const seal = await sealData2(session, {\n            password: passwordsMap,\n            ttl: sessionConfig.ttl\n          });\n          const cookieValue = (0,cookie__WEBPACK_IMPORTED_MODULE_0__.serialize)(\n            sessionConfig.cookieName,\n            seal,\n            sessionConfig.cookieOptions\n          );\n          if (cookieValue.length > 4096) {\n            throw new Error(\n              `iron-session: Cookie length is too big (${cookieValue.length} bytes), browsers will refuse it. Try to remove some data.`\n            );\n          }\n          setCookie(res, cookieValue);\n        }\n      },\n      destroy: {\n        value: function destroy() {\n          Object.keys(session).forEach((key) => {\n            delete session[key];\n          });\n          const cookieValue = (0,cookie__WEBPACK_IMPORTED_MODULE_0__.serialize)(sessionConfig.cookieName, \"\", {\n            ...sessionConfig.cookieOptions,\n            maxAge: 0\n          });\n          setCookie(res, cookieValue);\n        }\n      }\n    });\n    return session;\n  }\n}\nasync function getIronSessionFromCookieStore(cookieStore, sessionOptions, sealData2, unsealData2) {\n  if (!sessionOptions.cookieName) {\n    throw new Error(\"iron-session: Bad usage. Missing cookie name.\");\n  }\n  if (!sessionOptions.password) {\n    throw new Error(\"iron-session: Bad usage. Missing password.\");\n  }\n  const passwordsMap = normalizeStringPasswordToMap(sessionOptions.password);\n  if (Object.values(passwordsMap).some((password) => password.length < 32)) {\n    throw new Error(\n      \"iron-session: Bad usage. Password must be at least 32 characters long.\"\n    );\n  }\n  let sessionConfig = getSessionConfig(sessionOptions);\n  const sealFromCookies = getServerActionCookie(\n    sessionConfig.cookieName,\n    cookieStore\n  );\n  const session = sealFromCookies ? await unsealData2(sealFromCookies, {\n    password: passwordsMap,\n    ttl: sessionConfig.ttl\n  }) : {};\n  Object.defineProperties(session, {\n    updateConfig: {\n      value: function updateConfig(newSessionOptions) {\n        sessionConfig = getSessionConfig(newSessionOptions);\n      }\n    },\n    save: {\n      value: async function save() {\n        const seal = await sealData2(session, {\n          password: passwordsMap,\n          ttl: sessionConfig.ttl\n        });\n        const cookieLength = sessionConfig.cookieName.length + seal.length + JSON.stringify(sessionConfig.cookieOptions).length;\n        if (cookieLength > 4096) {\n          throw new Error(\n            `iron-session: Cookie length is too big (${cookieLength} bytes), browsers will refuse it. Try to remove some data.`\n          );\n        }\n        cookieStore.set(\n          sessionConfig.cookieName,\n          seal,\n          sessionConfig.cookieOptions\n        );\n      }\n    },\n    destroy: {\n      value: function destroy() {\n        Object.keys(session).forEach((key) => {\n          delete session[key];\n        });\n        const cookieOptions = { ...sessionConfig.cookieOptions, maxAge: 0 };\n        cookieStore.set(sessionConfig.cookieName, \"\", cookieOptions);\n      }\n    }\n  });\n  return session;\n}\nvar sealData = createSealData(uncrypto__WEBPACK_IMPORTED_MODULE_2__);\nvar unsealData = createUnsealData(uncrypto__WEBPACK_IMPORTED_MODULE_2__);\nvar getIronSession = createGetIronSession(sealData, unsealData);\n\n\n//# sourceMappingURL=index.js.map\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXJvbi1zZXNzaW9uL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTBDO0FBQ2M7QUFDckI7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2Q0FBSztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvREFBSTtBQUM3QixTQUFTLG9EQUFRO0FBQ2pCO0FBQ0EsS0FBSztBQUNMLGNBQWMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLG9CQUFvQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxZQUFZLG1DQUFtQztBQUMvQztBQUNBLHlCQUF5QixzREFBTTtBQUMvQixXQUFXLG9EQUFRO0FBQ25CO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLDhCQUE4QixpREFBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsb0JBQW9CO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLDhCQUE4QixpREFBUztBQUN2QztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOEJBQThCLHFDQUFNO0FBQ3BDLGtDQUFrQyxxQ0FBTTtBQUN4Qzs7QUFFZ0Q7QUFDaEQ7QUFDQSIsInNvdXJjZXMiOlsiRDpcXE5leHRKU1xcbWVkaWNhbCB3ZWJzaXRlXFxtZWRpY2FsLWNsaW5pY1xcbm9kZV9tb2R1bGVzXFxpcm9uLXNlc3Npb25cXGRpc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNlcmlhbGl6ZSwgcGFyc2UgfSBmcm9tICdjb29raWUnO1xuaW1wb3J0IHsgc2VhbCwgZGVmYXVsdHMsIHVuc2VhbCB9IGZyb20gJ2lyb24td2ViY3J5cHRvJztcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICd1bmNyeXB0byc7XG5cbi8vIHNyYy9jb3JlLnRzXG52YXIgdGltZXN0YW1wU2tld1NlYyA9IDYwO1xudmFyIGZvdXJ0ZWVuRGF5c0luU2Vjb25kcyA9IDE0ICogMjQgKiAzNjAwO1xudmFyIGN1cnJlbnRNYWpvclZlcnNpb24gPSAyO1xudmFyIHZlcnNpb25EZWxpbWl0ZXIgPSBcIn5cIjtcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgdHRsOiBmb3VydGVlbkRheXNJblNlY29uZHMsXG4gIGNvb2tpZU9wdGlvbnM6IHsgaHR0cE9ubHk6IHRydWUsIHNlY3VyZTogdHJ1ZSwgc2FtZVNpdGU6IFwibGF4XCIsIHBhdGg6IFwiL1wiIH1cbn07XG5mdW5jdGlvbiBub3JtYWxpemVTdHJpbmdQYXNzd29yZFRvTWFwKHBhc3N3b3JkKSB7XG4gIHJldHVybiB0eXBlb2YgcGFzc3dvcmQgPT09IFwic3RyaW5nXCIgPyB7IDE6IHBhc3N3b3JkIH0gOiBwYXNzd29yZDtcbn1cbmZ1bmN0aW9uIHBhcnNlU2VhbChzZWFsKSB7XG4gIGNvbnN0IFtzZWFsV2l0aG91dFZlcnNpb24sIHRva2VuVmVyc2lvbkFzU3RyaW5nXSA9IHNlYWwuc3BsaXQodmVyc2lvbkRlbGltaXRlcik7XG4gIGNvbnN0IHRva2VuVmVyc2lvbiA9IHRva2VuVmVyc2lvbkFzU3RyaW5nID09IG51bGwgPyBudWxsIDogcGFyc2VJbnQodG9rZW5WZXJzaW9uQXNTdHJpbmcsIDEwKTtcbiAgcmV0dXJuIHsgc2VhbFdpdGhvdXRWZXJzaW9uLCB0b2tlblZlcnNpb24gfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDb29raWVNYXhBZ2UodHRsKSB7XG4gIGlmICh0dGwgPT09IDApIHtcbiAgICByZXR1cm4gMjE0NzQ4MzY0NztcbiAgfVxuICByZXR1cm4gdHRsIC0gdGltZXN0YW1wU2tld1NlYztcbn1cbmZ1bmN0aW9uIGdldENvb2tpZShyZXEsIGNvb2tpZU5hbWUpIHtcbiAgcmV0dXJuIHBhcnNlKFxuICAgIChcImhlYWRlcnNcIiBpbiByZXEgJiYgdHlwZW9mIHJlcS5oZWFkZXJzLmdldCA9PT0gXCJmdW5jdGlvblwiID8gcmVxLmhlYWRlcnMuZ2V0KFwiY29va2llXCIpIDogcmVxLmhlYWRlcnMuY29va2llKSA/PyBcIlwiXG4gIClbY29va2llTmFtZV0gPz8gXCJcIjtcbn1cbmZ1bmN0aW9uIGdldFNlcnZlckFjdGlvbkNvb2tpZShjb29raWVOYW1lLCBjb29raWVIYW5kbGVyKSB7XG4gIGNvbnN0IGNvb2tpZU9iamVjdCA9IGNvb2tpZUhhbmRsZXIuZ2V0KGNvb2tpZU5hbWUpO1xuICBjb25zdCBjb29raWUgPSBjb29raWVPYmplY3Q/LnZhbHVlO1xuICBpZiAodHlwZW9mIGNvb2tpZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBjb29raWU7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5mdW5jdGlvbiBzZXRDb29raWUocmVzLCBjb29raWVWYWx1ZSkge1xuICBpZiAoXCJoZWFkZXJzXCIgaW4gcmVzICYmIHR5cGVvZiByZXMuaGVhZGVycy5hcHBlbmQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJlcy5oZWFkZXJzLmFwcGVuZChcInNldC1jb29raWVcIiwgY29va2llVmFsdWUpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZXhpc3RpbmdTZXRDb29raWUgPSByZXMuZ2V0SGVhZGVyKFwic2V0LWNvb2tpZVwiKSA/PyBbXTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV4aXN0aW5nU2V0Q29va2llKSkge1xuICAgIGV4aXN0aW5nU2V0Q29va2llID0gW2V4aXN0aW5nU2V0Q29va2llLnRvU3RyaW5nKCldO1xuICB9XG4gIHJlcy5zZXRIZWFkZXIoXCJzZXQtY29va2llXCIsIFtcbiAgICAuLi5leGlzdGluZ1NldENvb2tpZSxcbiAgICBjb29raWVWYWx1ZVxuICBdKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlYWxEYXRhKF9jcnlwdG8pIHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIHNlYWxEYXRhMihkYXRhLCB7XG4gICAgcGFzc3dvcmQsXG4gICAgdHRsID0gZm91cnRlZW5EYXlzSW5TZWNvbmRzXG4gIH0pIHtcbiAgICBjb25zdCBwYXNzd29yZHNNYXAgPSBub3JtYWxpemVTdHJpbmdQYXNzd29yZFRvTWFwKHBhc3N3b3JkKTtcbiAgICBjb25zdCBtb3N0UmVjZW50UGFzc3dvcmRJZCA9IE1hdGgubWF4KFxuICAgICAgLi4uT2JqZWN0LmtleXMocGFzc3dvcmRzTWFwKS5tYXAoTnVtYmVyKVxuICAgICk7XG4gICAgY29uc3QgcGFzc3dvcmRGb3JTZWFsID0ge1xuICAgICAgaWQ6IG1vc3RSZWNlbnRQYXNzd29yZElkLnRvU3RyaW5nKCksXG4gICAgICBzZWNyZXQ6IHBhc3N3b3Jkc01hcFttb3N0UmVjZW50UGFzc3dvcmRJZF1cbiAgICB9O1xuICAgIGNvbnN0IHNlYWwkMSA9IGF3YWl0IHNlYWwoX2NyeXB0bywgZGF0YSwgcGFzc3dvcmRGb3JTZWFsLCB7XG4gICAgICAuLi5kZWZhdWx0cyxcbiAgICAgIHR0bDogdHRsICogMWUzXG4gICAgfSk7XG4gICAgcmV0dXJuIGAke3NlYWwkMX0ke3ZlcnNpb25EZWxpbWl0ZXJ9JHtjdXJyZW50TWFqb3JWZXJzaW9ufWA7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVVbnNlYWxEYXRhKF9jcnlwdG8pIHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIHVuc2VhbERhdGEyKHNlYWwsIHtcbiAgICBwYXNzd29yZCxcbiAgICB0dGwgPSBmb3VydGVlbkRheXNJblNlY29uZHNcbiAgfSkge1xuICAgIGNvbnN0IHBhc3N3b3Jkc01hcCA9IG5vcm1hbGl6ZVN0cmluZ1Bhc3N3b3JkVG9NYXAocGFzc3dvcmQpO1xuICAgIGNvbnN0IHsgc2VhbFdpdGhvdXRWZXJzaW9uLCB0b2tlblZlcnNpb24gfSA9IHBhcnNlU2VhbChzZWFsKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHVuc2VhbChfY3J5cHRvLCBzZWFsV2l0aG91dFZlcnNpb24sIHBhc3N3b3Jkc01hcCwge1xuICAgICAgICAuLi5kZWZhdWx0cyxcbiAgICAgICAgdHRsOiB0dGwgKiAxZTNcbiAgICAgIH0pID8/IHt9O1xuICAgICAgaWYgKHRva2VuVmVyc2lvbiA9PT0gMikge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IC4uLmRhdGEucGVyc2lzdGVudCB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAvXihFeHBpcmVkIHNlYWx8QmFkIGhtYWMgdmFsdWV8Q2Fubm90IGZpbmQgcGFzc3dvcmR8SW5jb3JyZWN0IG51bWJlciBvZiBzZWFsZWQgY29tcG9uZW50cykvLnRlc3QoXG4gICAgICAgIGVycm9yLm1lc3NhZ2VcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U2Vzc2lvbkNvbmZpZyhzZXNzaW9uT3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIC4uLnNlc3Npb25PcHRpb25zLFxuICAgIGNvb2tpZU9wdGlvbnM6IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLmNvb2tpZU9wdGlvbnMsXG4gICAgICAuLi5zZXNzaW9uT3B0aW9ucy5jb29raWVPcHRpb25zIHx8IHt9XG4gICAgfVxuICB9O1xuICBpZiAoc2Vzc2lvbk9wdGlvbnMuY29va2llT3B0aW9ucyAmJiBcIm1heEFnZVwiIGluIHNlc3Npb25PcHRpb25zLmNvb2tpZU9wdGlvbnMpIHtcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnMuY29va2llT3B0aW9ucy5tYXhBZ2UgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucy50dGwgPSAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmNvb2tpZU9wdGlvbnMubWF4QWdlID0gY29tcHV0ZUNvb2tpZU1heEFnZShvcHRpb25zLnR0bCk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG52YXIgYmFkVXNhZ2VNZXNzYWdlID0gXCJpcm9uLXNlc3Npb246IEJhZCB1c2FnZTogdXNlIGdldElyb25TZXNzaW9uKHJlcSwgcmVzLCBvcHRpb25zKSBvciBnZXRJcm9uU2Vzc2lvbihjb29raWVTdG9yZSwgb3B0aW9ucykuXCI7XG5mdW5jdGlvbiBjcmVhdGVHZXRJcm9uU2Vzc2lvbihzZWFsRGF0YTIsIHVuc2VhbERhdGEyKSB7XG4gIHJldHVybiBnZXRJcm9uU2Vzc2lvbjI7XG4gIGFzeW5jIGZ1bmN0aW9uIGdldElyb25TZXNzaW9uMihyZXFPckNvb2tpZVN0b3JlLCByZXNPcnNlc3Npb25PcHRpb25zLCBzZXNzaW9uT3B0aW9ucykge1xuICAgIGlmICghcmVxT3JDb29raWVTdG9yZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGJhZFVzYWdlTWVzc2FnZSk7XG4gICAgfVxuICAgIGlmICghcmVzT3JzZXNzaW9uT3B0aW9ucykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGJhZFVzYWdlTWVzc2FnZSk7XG4gICAgfVxuICAgIGlmICghc2Vzc2lvbk9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBnZXRJcm9uU2Vzc2lvbkZyb21Db29raWVTdG9yZShcbiAgICAgICAgcmVxT3JDb29raWVTdG9yZSxcbiAgICAgICAgcmVzT3JzZXNzaW9uT3B0aW9ucyxcbiAgICAgICAgc2VhbERhdGEyLFxuICAgICAgICB1bnNlYWxEYXRhMlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVxID0gcmVxT3JDb29raWVTdG9yZTtcbiAgICBjb25zdCByZXMgPSByZXNPcnNlc3Npb25PcHRpb25zO1xuICAgIGlmICghc2Vzc2lvbk9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihiYWRVc2FnZU1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAoIXNlc3Npb25PcHRpb25zLmNvb2tpZU5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlyb24tc2Vzc2lvbjogQmFkIHVzYWdlLiBNaXNzaW5nIGNvb2tpZSBuYW1lLlwiKTtcbiAgICB9XG4gICAgaWYgKCFzZXNzaW9uT3B0aW9ucy5wYXNzd29yZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXJvbi1zZXNzaW9uOiBCYWQgdXNhZ2UuIE1pc3NpbmcgcGFzc3dvcmQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYXNzd29yZHNNYXAgPSBub3JtYWxpemVTdHJpbmdQYXNzd29yZFRvTWFwKHNlc3Npb25PcHRpb25zLnBhc3N3b3JkKTtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhwYXNzd29yZHNNYXApLnNvbWUoKHBhc3N3b3JkKSA9PiBwYXNzd29yZC5sZW5ndGggPCAzMikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJpcm9uLXNlc3Npb246IEJhZCB1c2FnZS4gUGFzc3dvcmQgbXVzdCBiZSBhdCBsZWFzdCAzMiBjaGFyYWN0ZXJzIGxvbmcuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCBzZXNzaW9uQ29uZmlnID0gZ2V0U2Vzc2lvbkNvbmZpZyhzZXNzaW9uT3B0aW9ucyk7XG4gICAgY29uc3Qgc2VhbEZyb21Db29raWVzID0gZ2V0Q29va2llKHJlcSwgc2Vzc2lvbkNvbmZpZy5jb29raWVOYW1lKTtcbiAgICBjb25zdCBzZXNzaW9uID0gc2VhbEZyb21Db29raWVzID8gYXdhaXQgdW5zZWFsRGF0YTIoc2VhbEZyb21Db29raWVzLCB7XG4gICAgICBwYXNzd29yZDogcGFzc3dvcmRzTWFwLFxuICAgICAgdHRsOiBzZXNzaW9uQ29uZmlnLnR0bFxuICAgIH0pIDoge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2Vzc2lvbiwge1xuICAgICAgdXBkYXRlQ29uZmlnOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVDb25maWcobmV3U2Vzc2lvbk9wdGlvbnMpIHtcbiAgICAgICAgICBzZXNzaW9uQ29uZmlnID0gZ2V0U2Vzc2lvbkNvbmZpZyhuZXdTZXNzaW9uT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzYXZlOiB7XG4gICAgICAgIHZhbHVlOiBhc3luYyBmdW5jdGlvbiBzYXZlKCkge1xuICAgICAgICAgIGlmIChcImhlYWRlcnNTZW50XCIgaW4gcmVzICYmIHJlcy5oZWFkZXJzU2VudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcImlyb24tc2Vzc2lvbjogQ2Fubm90IHNldCBzZXNzaW9uIGNvb2tpZTogc2Vzc2lvbi5zYXZlKCkgd2FzIGNhbGxlZCBhZnRlciBoZWFkZXJzIHdlcmUgc2VudC4gTWFrZSBzdXJlIHRvIGNhbGwgaXQgYmVmb3JlIGFueSByZXMuc2VuZCgpIG9yIHJlcy5lbmQoKVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzZWFsID0gYXdhaXQgc2VhbERhdGEyKHNlc3Npb24sIHtcbiAgICAgICAgICAgIHBhc3N3b3JkOiBwYXNzd29yZHNNYXAsXG4gICAgICAgICAgICB0dGw6IHNlc3Npb25Db25maWcudHRsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgY29va2llVmFsdWUgPSBzZXJpYWxpemUoXG4gICAgICAgICAgICBzZXNzaW9uQ29uZmlnLmNvb2tpZU5hbWUsXG4gICAgICAgICAgICBzZWFsLFxuICAgICAgICAgICAgc2Vzc2lvbkNvbmZpZy5jb29raWVPcHRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoY29va2llVmFsdWUubGVuZ3RoID4gNDA5Nikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgaXJvbi1zZXNzaW9uOiBDb29raWUgbGVuZ3RoIGlzIHRvbyBiaWcgKCR7Y29va2llVmFsdWUubGVuZ3RofSBieXRlcyksIGJyb3dzZXJzIHdpbGwgcmVmdXNlIGl0LiBUcnkgdG8gcmVtb3ZlIHNvbWUgZGF0YS5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRDb29raWUocmVzLCBjb29raWVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZXN0cm95OiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHNlc3Npb24pLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHNlc3Npb25ba2V5XTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBjb29raWVWYWx1ZSA9IHNlcmlhbGl6ZShzZXNzaW9uQ29uZmlnLmNvb2tpZU5hbWUsIFwiXCIsIHtcbiAgICAgICAgICAgIC4uLnNlc3Npb25Db25maWcuY29va2llT3B0aW9ucyxcbiAgICAgICAgICAgIG1heEFnZTogMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNldENvb2tpZShyZXMsIGNvb2tpZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZXNzaW9uO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRJcm9uU2Vzc2lvbkZyb21Db29raWVTdG9yZShjb29raWVTdG9yZSwgc2Vzc2lvbk9wdGlvbnMsIHNlYWxEYXRhMiwgdW5zZWFsRGF0YTIpIHtcbiAgaWYgKCFzZXNzaW9uT3B0aW9ucy5jb29raWVOYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaXJvbi1zZXNzaW9uOiBCYWQgdXNhZ2UuIE1pc3NpbmcgY29va2llIG5hbWUuXCIpO1xuICB9XG4gIGlmICghc2Vzc2lvbk9wdGlvbnMucGFzc3dvcmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpcm9uLXNlc3Npb246IEJhZCB1c2FnZS4gTWlzc2luZyBwYXNzd29yZC5cIik7XG4gIH1cbiAgY29uc3QgcGFzc3dvcmRzTWFwID0gbm9ybWFsaXplU3RyaW5nUGFzc3dvcmRUb01hcChzZXNzaW9uT3B0aW9ucy5wYXNzd29yZCk7XG4gIGlmIChPYmplY3QudmFsdWVzKHBhc3N3b3Jkc01hcCkuc29tZSgocGFzc3dvcmQpID0+IHBhc3N3b3JkLmxlbmd0aCA8IDMyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiaXJvbi1zZXNzaW9uOiBCYWQgdXNhZ2UuIFBhc3N3b3JkIG11c3QgYmUgYXQgbGVhc3QgMzIgY2hhcmFjdGVycyBsb25nLlwiXG4gICAgKTtcbiAgfVxuICBsZXQgc2Vzc2lvbkNvbmZpZyA9IGdldFNlc3Npb25Db25maWcoc2Vzc2lvbk9wdGlvbnMpO1xuICBjb25zdCBzZWFsRnJvbUNvb2tpZXMgPSBnZXRTZXJ2ZXJBY3Rpb25Db29raWUoXG4gICAgc2Vzc2lvbkNvbmZpZy5jb29raWVOYW1lLFxuICAgIGNvb2tpZVN0b3JlXG4gICk7XG4gIGNvbnN0IHNlc3Npb24gPSBzZWFsRnJvbUNvb2tpZXMgPyBhd2FpdCB1bnNlYWxEYXRhMihzZWFsRnJvbUNvb2tpZXMsIHtcbiAgICBwYXNzd29yZDogcGFzc3dvcmRzTWFwLFxuICAgIHR0bDogc2Vzc2lvbkNvbmZpZy50dGxcbiAgfSkgOiB7fTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2Vzc2lvbiwge1xuICAgIHVwZGF0ZUNvbmZpZzoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUNvbmZpZyhuZXdTZXNzaW9uT3B0aW9ucykge1xuICAgICAgICBzZXNzaW9uQ29uZmlnID0gZ2V0U2Vzc2lvbkNvbmZpZyhuZXdTZXNzaW9uT3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzYXZlOiB7XG4gICAgICB2YWx1ZTogYXN5bmMgZnVuY3Rpb24gc2F2ZSgpIHtcbiAgICAgICAgY29uc3Qgc2VhbCA9IGF3YWl0IHNlYWxEYXRhMihzZXNzaW9uLCB7XG4gICAgICAgICAgcGFzc3dvcmQ6IHBhc3N3b3Jkc01hcCxcbiAgICAgICAgICB0dGw6IHNlc3Npb25Db25maWcudHRsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjb29raWVMZW5ndGggPSBzZXNzaW9uQ29uZmlnLmNvb2tpZU5hbWUubGVuZ3RoICsgc2VhbC5sZW5ndGggKyBKU09OLnN0cmluZ2lmeShzZXNzaW9uQ29uZmlnLmNvb2tpZU9wdGlvbnMpLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvb2tpZUxlbmd0aCA+IDQwOTYpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgaXJvbi1zZXNzaW9uOiBDb29raWUgbGVuZ3RoIGlzIHRvbyBiaWcgKCR7Y29va2llTGVuZ3RofSBieXRlcyksIGJyb3dzZXJzIHdpbGwgcmVmdXNlIGl0LiBUcnkgdG8gcmVtb3ZlIHNvbWUgZGF0YS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb29raWVTdG9yZS5zZXQoXG4gICAgICAgICAgc2Vzc2lvbkNvbmZpZy5jb29raWVOYW1lLFxuICAgICAgICAgIHNlYWwsXG4gICAgICAgICAgc2Vzc2lvbkNvbmZpZy5jb29raWVPcHRpb25zXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZXN0cm95OiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoc2Vzc2lvbikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgZGVsZXRlIHNlc3Npb25ba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNvb2tpZU9wdGlvbnMgPSB7IC4uLnNlc3Npb25Db25maWcuY29va2llT3B0aW9ucywgbWF4QWdlOiAwIH07XG4gICAgICAgIGNvb2tpZVN0b3JlLnNldChzZXNzaW9uQ29uZmlnLmNvb2tpZU5hbWUsIFwiXCIsIGNvb2tpZU9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzZXNzaW9uO1xufVxudmFyIHNlYWxEYXRhID0gY3JlYXRlU2VhbERhdGEoY3J5cHRvKTtcbnZhciB1bnNlYWxEYXRhID0gY3JlYXRlVW5zZWFsRGF0YShjcnlwdG8pO1xudmFyIGdldElyb25TZXNzaW9uID0gY3JlYXRlR2V0SXJvblNlc3Npb24oc2VhbERhdGEsIHVuc2VhbERhdGEpO1xuXG5leHBvcnQgeyBnZXRJcm9uU2Vzc2lvbiwgc2VhbERhdGEsIHVuc2VhbERhdGEgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/iron-session/dist/index.js\n");

/***/ })

};
;